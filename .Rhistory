FXrate.str <- paste(p.ccy.str, a.ccy.str, sep = "")
FXrate.str
FXrate <- try(get(FXrate.str), silent = TRUE)
FXrate
inherits(FXrate, "try-error")
invert = TRUE
p.ccy.str
a.ccy.str
is.na(CcyMult) && !is.na(FXrate)
inherits(FXrate, "xts")
CcyMult <- FXrate[Dates]
CcyMult <- na.locf(merge(CcyMult, index(psummary)))
CcyMult <- drop(CcyMult[index(psummary)])
head(CcyMult)
?na.locf
head(index(psummary))
head(1/CcyMult)
CcyMult <- 1/CcyMult
psummary <- psummary * CcyMult
?getFX
source('~/GitHub/altfund/SystematicTrading.R')
head(CcyMult[c("high", "low", "open", "close")]
)
head(CcyMult[c("high", "low", "open", "close"),])
head(CcyMult)
str(CcyMult)
head(CcyMult[c("high", "low", "open", "close")])
head(CcyMult[mc("high", "low", "open", "close")])
head(CcyMult[,c("high", "low", "open", "close")])
head(psummary * CcyMult[,c("high", "low", "open", "close")])
head(psummary * CcyMult[,c("close")])
str(psummary)
head(psummary)
head(CcyMult[,c("high", "low", "open", "close")])
str(CcyMult[,c("high", "low", "open", "close")])
str(psummary)
inherits(FXrate, "xts")
CcyMult <- FXrate[Dates]
CcyMult <- na.locf(merge(CcyMult, index(psummary)))
CcyMult <- drop(CcyMult[index(psummary)])
head(CcyMult)
psummary <- psummary * CcyMult
?get
source('~/GitHub/altfund/backtester.R')
head(mktdata)
head(Cl(mktdata))
updatePortf(Portfolio=portfolio.name,Dates=paste('::',as.Date(Sys.time()),sep=''))
applyStrategy(strategy.name,
portfolios=portfolio.name, debug=T,
parameters=list(nFast = .nFast, nSlow = .nSlow, nSig = .nSig, maType = 'EMA'),
verbose=TRUE)
source('~/GitHub/altfund/backtester.R')
applyStrategy(strategy.name,
portfolios=portfolio.name, debug=T,
parameters=list(nFast = .nFast, nSlow = .nSlow, nSig = .nSig, maType = 'EMA'),
verbose=TRUE)
updatePortf(Portfolio=portfolio.name,Dates=paste('::',as.Date(Sys.time()),sep=''))
updateAcct(account.name,Dates=paste('::',as.Date(Sys.time()),sep=''))
updateAcct(account.name)
updateEndEq(account.name)
t(tradeStats(portfolio.name))
getTxns(portfolio.name, Symbol = 'BTC_ETH')
perTradeStats(portfolio.name, "BTC_ETH")
chart.Posn(Portfolio=portfolio.name,Symbol=symbols, type = "line", log.scale = T)
chart.Posn(Portfolio=portfolio.name,Symbol=symbols, type = "line", log.scale = F)
library(lattice)
a <- getAccount(account.name)
xyplot(a$summary,type="h",col=4)
equity <- a$summary$End.Eq
plot(equity,main="Giulio Strategy Equity Curve")
ret <- Return.calculate(equity,method="log")
charts.PerformanceSummary(ret, colorset = bluefocus,
main="Giulio Strategy Performance")
# plot(add_Vo()
any(is.na(equity))
ret <- Return.calculate(equity,method="log", na.rm=T)
ret <- Return.calculate(equity)
charts.PerformanceSummary(ret, colorset = bluefocus,
main="Giulio Strategy Performance")
any(is.na(ret))
ret <- na.rm(Return.calculate(equity))
ret <- na.omit(Return.calculate(equity))
charts.PerformanceSummary(ret, colorset = bluefocus,
main="Giulio Strategy Performance")
ret
head(ret)
head(equity)
head(Return.calculate(equity))
?is.finite()
head(ret[is.finite(ret)])
source('~/GitHub/altfund/backtester.R')
source('~/GitHub/altfund/backtester.R')
xyplot(a$summary,type="h",col=4)
chart.Posn(Portfolio=portfolio.name,Symbol=symbols, type = "line", log.scale = F)
head(equity)
tail(equity)
?add.rule
?add.indicator
?MACD
MACD
?volatility
pair
hour.price.xts <- getHourlyPairData(pair)
volatility.lookback <- config$volatility.lookback
tail(sqrt(EMA(CalculateReturns(hour.price.xts), n=36)))
head(sqrt(EMA(CalculateReturns(hour.price.xts), n=36)))
head(sqrt(EMA(CalculateReturns(hour.price.xts)^2, n=36)))
tail(sqrt(EMA(CalculateReturns(hour.price.xts)^2, n=36)))
source('~/GitHub/altfund/SystematicTrading.R')
?add.indicator
add.indicator(strategy.name, name= "emaVolatility", arguments = list(price.xts=quote(Cl(mktdata))), label='volatility')
head(mktdata)
rm.strat(portfolio.name)
rm.strat(account.name)
rm.strat(strategy.name)
## Initialize Portfolio, Account, and Orderbook
initPortf(name = portfolio.name, symbols = symbols, initPosQty = 0, initDate = initDate, currency = "BTC")  # getPortfolio(portfolio.name)
initAcct(name = account.name, portfolios = portfolio.name, initDate = initDate, initEq = 0, currency = "USD")  # getAccount(account.name)
initOrders(portfolio = portfolio.name, symbols = symbols, initDate = initDate)  # getOrderBook(portfolio.name)
strategy(strategy.name, store = TRUE)  # summary(getStrategy(strategy.name))
add.indicator(strategy.name, name= "emaVolatility", arguments = list(price.xts=quote(Cl(mktdata))), label='volatility')
head(mktdata)
BTC_ETH <- getHourlyPairData(pair=pair, ohlc=TRUE, volume=TRUE) # getHourlyPairData
BTCUSD <- getHourlyPairData(pair="USDT_BTC", ohlc=FALSE, volume=FALSE)
# combo.prices <- na.omit(merge(BTC_ETH, BTCUSD))
# BTC_ETH <- BTC_ETH[index(combo.prices)]
# BTCUSD <- BTCUSD[index(combo.prices)]
# ETHBTC2 <- to.hourly(ethbtc.30m.xts[,c("open", "high", "low", "close", "volume")], indexAt="endof", OHLC=FALSE) # ["2015-09-01::"]
## Define instruments
currency(c('BTC', 'ETH', 'USD')) # ls_currencies()
exchange_rate('BTC_ETH', currency = 'BTC', counter_currency = 'ETH', tick_size = 0.00001)
exchange_rate('BTCUSD', currency = 'USD', counter_currency = 'BTC', tick_size = 0.01)
initDate = as.character(as.Date(min(index(ETHBTC))-days(1))) # '2015-09-01'
initBTC <- .5
initETH <- 0
portfolio.name <- "bitcoin_margin"
account.name <- "poloniex"
strategy.name <- "asset_allocation"
symbols <- c("BTC_ETH") #, "BTCUSD")
## To rerun
rm.strat(portfolio.name)
rm.strat(account.name)
rm.strat(strategy.name)
## Initialize Portfolio, Account, and Orderbook
initPortf(name = portfolio.name, symbols = symbols, initPosQty = 0, initDate = initDate, currency = "BTC")  # getPortfolio(portfolio.name)
initAcct(name = account.name, portfolios = portfolio.name, initDate = initDate, initEq = 0, currency = "USD")  # getAccount(account.name)
initOrders(portfolio = portfolio.name, symbols = symbols, initDate = initDate)  # getOrderBook(portfolio.name)
strategy(strategy.name, store = TRUE)  # summary(getStrategy(strategy.name))
## Indicators
# # Parameters
# .nFast = 60 # 90
# .nSlow = 130
# .nSig = 45 # 75
head(mktdaeta)
head(mktdata)
list(price.xts=quote(Cl(mktdata)))
?add.signal
?applyIndicators
applyIndicators()
applyIndicators(strategy.name)
head(mktdata)
str(mktdata)
?add.signal
str(config)
str(quantstrat)
?repeat
?seq
100*.01
?add.rule
?getPrice
ruleSignal
?addPosLimit
source('~/GitHub/altfund/backtester.R')
source('~/GitHub/altfund/backtester.R')
library(httr)
library(plyr)
library(quantstrat) # install.packages("quantstrat", repos="http://R-Forge.R-project.org")
library(PerformanceAnalytics)
library(IKTrading)  # install_github("IlyaKipnis/IKTrading") needs devtools
library(lattice)
library(doParallel)
# library(doMC) # install.packages("doMC", repos="http://R-Forge.R-project.org")
# registerDoMC(cores=detectCores())
registerDoParallel()
emaVolatility <- function(price.xts){
ema.volatility <- sqrt(EMA(CalculateReturns(hour.price.xts)^2, n=36))
return(ema.volatility)
}
scaledForecast <- function(price.xts){
scaled.forecast <- rep(10, times=length(index(price.xts)))
return(scaled.forecast)
}
cashVolatilityTarget <- function(exchange.rate=getExchangeRate()){
account.value=config$poloniex.margin.value
# returns the cash volatility target in USDT
volatility.target <- config$volatility.target
cash.volatility.target <- account.value * volatility.target * exchange.rate
return(cash.volatility.target)
}
instrumentValueVolatility <- function(exchange.rate=getExchangeRate(), pair=NULL, hour.price.xts=NULL){
if(is.null(hour.price.xts)){
block.size <- getExchangeRate(pair=pair)     # minimum.order.size <- config$minimum.order.size
}
else {
block.size <- as.numeric(tail(hour.price.xts,1))
}
volatility.lookback <- config$volatility.lookback
# hour.price.xts <- getHourlyPairData(pair)
block.value <- block.size * .01 # change in price when block moves 1%, BTC/XRP
price.volatility <- 100*as.numeric(tail(calculateVolatility(pair, hour.price.xts=hour.price.xts),1)) # ewma of 36 trading periods
instrument.currency.volatility <- block.value * price.volatility # expected hourly profit/loss in instrument units
## ^^ can be simplified to block.size * price.volatility when there is one asset per block (i.e. equities, raw FX)
## However, framework adapts to futures, etc.
## We are calculating the impact a % price move in the asset has on our bottom line per [hour], then
## How many % price moves we should expect per [hour]
instrument.value.volatility <- instrument.currency.volatility * exchange.rate # instrument.currency.volatility converted to account value currency
return(instrument.value.volatility)
}
volatilityScalar <- function(pair=NULL, hour.price.xts=NULL){
cash.volatility.target=cashVolatilityTarget()
instrument.value.volatility=instrumentValueVolatility(pair=pair, hour.price.xts = hour.price.xts)
volatility.scalar <- cash.volatility.target/instrument.value.volatility # unitless
return(volatility.scalar)
}
subsystemPosition <- function(pair=NULL, five.minute.price.xts=NULL){
if(is.null(five.minute.price.xts)){
five.minute.price.xts <- getPairData(pair)
}
hour.price.xts <- to.hourly(five.minute.price.xts, OHLC=FALSE, indexAt="endof")
volatility.scalar=volatilityScalar(pair=pair, hour.price.xts=hour.price.xts)
combined.instrument.forecast=combinedInstrumentForecast(pair=pair, five.minute.price.xts=five.minute.price.xts)
system.forecast.average = 10 # by design this should be 10
subsystem.position <- (volatility.scalar * combined.instrument.forecast)/system.forecast.average
return(subsystem.position)
}
# poloniex.ohlc.30m <- content(GET("https://poloniex.com/public?command=returnChartData&currencyPair=BTC_ETH&start=1439010600&end=9999999999&period=1800"))  # https://poloniex.com/support/api/
pair <- "BTC_ETH"
# poloniex.ohlc.5m <- read.csv(paste0(getwd(),"/data/raw/",pair,"_ohlc.csv"), stringsAsFactors = FALSE)
# ETHBTC.5m <- poloniex.ohlc.5m
# # ETHBTC.5m <- ldply(poloniex.ohlc.5m, data.frame)  # Convert OHLCV to data.frame
# ETHBTC.5m$date <- as.POSIXct(ETHBTC.5m$date,  tz="UTC")
#
# # Create 'xts' object:
# ethbtc.30m.xts <- xts(ETHBTC.5m[, 2:8], order.by = ETHBTC.5m$date)  # is.OHLCV(ETHBTC.30m)
# Rebuild empty environments if RStudio's "Clear All" has been used:
if (!exists('.instrument')) .instrument <- new.env()
if (!exists('.blotter')) .blotter <- new.env()
if (!exists('.strategy')) .strategy <- new.env()
## Optional: Subset timeframe
BTC_ETH <- getHourlyPairData(pair=pair, ohlc=TRUE, volume=TRUE) # getHourlyPairData
BTCUSD <- getHourlyPairData(pair="USDT_BTC", ohlc=FALSE, volume=FALSE)
# combo.prices <- na.omit(merge(BTC_ETH, BTCUSD))
# BTC_ETH <- BTC_ETH[index(combo.prices)]
# BTCUSD <- BTCUSD[index(combo.prices)]
# ETHBTC2 <- to.hourly(ethbtc.30m.xts[,c("open", "high", "low", "close", "volume")], indexAt="endof", OHLC=FALSE) # ["2015-09-01::"]
## Define instruments
currency(c('BTC', 'ETH', 'USD')) # ls_currencies()
exchange_rate('BTC_ETH', currency = 'BTC', counter_currency = 'ETH', tick_size = 0.00001)
exchange_rate('BTCUSD', currency = 'USD', counter_currency = 'BTC', tick_size = 0.01)
initDate = as.character(as.Date(min(index(ETHBTC))-days(1))) # '2015-09-01'
initBTC <- .5
initETH <- 0
portfolio.name <- "bitcoin_margin"
account.name <- "poloniex"
strategy.name <- "asset_allocation"
symbols <- c("BTC_ETH") #, "BTCUSD")
## To rerun
rm.strat(portfolio.name)
rm.strat(account.name)
rm.strat(strategy.name)
initPortf(name = portfolio.name, symbols = symbols, initPosQty = 0, initDate = initDate, currency = "BTC")  # getPortfolio(portfolio.name)
initAcct(name = account.name, portfolios = portfolio.name, initDate = initDate, initEq = 0, currency = "USD")  # getAccount(account.name)
initOrders(portfolio = portfolio.name, symbols = symbols, initDate = initDate)  # getOrderBook(portfolio.name)
strategy(strategy.name, store = TRUE)  # summary(getStrategy(strategy.name))
add.indicator(strategy.name, name= "emaVolatility", arguments = list(price.xts=Cl(mktdata)), label='volatility')
add.indicator(strategy.name, name="scaledForecast", arguments = list(price.xts=Cl(mktdata)), label='forecast')
subsystemPosition <- function (trade.percent=.02,
...,
longlevels=1,
shortlevels=1,
digits=NULL,
refprice=NULL,
portfolio,
symbol,
timestamp)
{
dummy <- updatePortf(Portfolio=portfolio,
Dates=paste('::',timestamp,sep=''))
trading.pl <- sum(.getPortfolio(portfolio)$summary$Net.Trading.PL)
total.equity <- initEq+trading.pl
tradeSize <- total.equity * trade.percent
if(length(refprice)>1) refprice <- refprice[,1]
if(!is.null(refprice)) tradeSize <- tradeSize/refprice
if(!is.null(digits)) tradeSize<-round(tradeSize,digits)
addPosLimit(portfolio = portfolio,
symbol = symbol,
timestamp = timestamp,
maxpos = tradeSize,
longlevels = longlevels,
minpos = -tradeSize,
shortlevels = shortlevels)
}
add.rule(strategy.name, 'subsystemPosition',
arguments=list(rebalance_on='hours',
trade.percent=.02,
refprice=quote(last(getPrice(mktdata)[paste('::',curIndex,sep='')])[,1]),
digits=0
),
type='rebalance',
label='rebalance')
applyStrategy(strategy.name,
portfolios=portfolio.name, debug=T,
parameters=list(nFast = .nFast, nSlow = .nSlow, nSig = .nSig, maType = 'EMA'),
verbose=TRUE)
applyStrategy
applyStrategy.rebalancing
applyStrategy.rebalancing(strategy.name,
portfolios=portfolio.name, debug=T,
parameters=list(nFast = .nFast, nSlow = .nSlow, nSig = .nSig, maType = 'EMA'),
verbose=TRUE)
?applyStrategy
source('~/GitHub/altfund/backtester.R')
source('~/GitHub/altfund/backtester.R')
source('~/GitHub/altfund/backtester.R')
head(mktdata)
source('~/GitHub/altfund/backtester.R')
source('~/GitHub/altfund/SystematicTrading.R')
source('~/GitHub/altfund/backtester.R')
ls()
source("SystematicTrading.R")
source('~/GitHub/altfund/backtester.R')
source('~/GitHub/altfund/backtester.R')
ls()
add.indicator(strategy.name, name= "emaVolatility", arguments = list(price.xts=Cl(mktdata)), label='volatility')
add.indicator(strategy.name, name= "emaVolatility", arguments = list(price.xts=quote(Cl(mktdata))), label='volatility')
source('~/GitHub/altfund/backtester.R')
source('~/GitHub/altfund/backtester.R')
head(mktdata)
?walk.forward
applyStrategy.rebalancing(strategy.name,
portfolios=portfolio.name, debug=T,
parameters=list(),
verbose=TRUE)
strategy.name
?get.orderbook()
ls()
applyIndicators(strategy.name)
?initSymbol
summary(getStrategy(strategy.name))
?strategy
?initPortf
getPortfolio(portfolio.name)
initPortf(name = portfolio.name, symbols = symbols, initPosQty = 0, initDate = initDate, currency = "BTC")  # getPortfolio(portfolio.name)
applyStrategy
get(ETHBTC)
get("ETHBTC")
applyStrategy
mkdata <- get("ETHBTC")
head(mktdata)
mktdata <- get("ETHBTC")
head(mktdata)
applyIndicators(strategy.name, ETHBTC)
rm.strat(strategy.name)
strategy(strategy.name, store = TRUE)  # summary(getStrategy(strategy.name))
add.indicator(strategy.name, name= "emaVolatility", arguments = list(price.xts=quote(Cl(mktdata))), label='volatility')
applyIndicators(strategy.name, ETHBTC)
head(mkdtata)
head(mktdtata)
head(applyIndicators(strategy.name, ETHBTC))
tail(applyIndicators(strategy.name, ETHBTC))
rm.strat(strategy.name)
strategy(strategy.name, store = TRUE)  # summary(getStrategy(strategy.name))
add.indicator(strategy.name, name="scaledForecast", arguments = list(price.xts=quote(Cl(mktdata))), label='forecast')
tail(applyIndicators(strategy.name, ETHBTC))
scaledForecast <- function(price.xts){
scaled.forecast <- xts(x=rep(10, times=length(index(price.xts))), order.by = index(price.xts))
return(scaled.forecast)
}
rm.strat(strategy.name)
strategy(strategy.name, store = TRUE)  # summary(getStrategy(strategy.name))
add.indicator(strategy.name, name="scaledForecast", arguments = list(price.xts=quote(Cl(mktdata))), label='forecast')
tail(applyIndicators(strategy.name, ETHBTC))
EMA
applyIndicators
head(mktdata)
names(mktdata)
emaVolatility <- function(price.xts){
ema.volatility <- sqrt(EMA(CalculateReturns(price.xts)^2, n=36))
colnames(ema.volatility) <- NULL
return(ema.volatility)
}
scaledForecast <- function(price.xts){
scaled.forecast <- xts(x=rep(10, times=length(index(price.xts))), order.by = index(price.xts))
colnames(scaled.forecast) <- NULL
return(scaled.forecast)
}
rm.strat(strategy.name)
strategy(strategy.name, store = TRUE)  # summary(getStrategy(strategy.name))
add.indicator(strategy.name, name= "emaVolatility", arguments = list(price.xts=quote(Cl(mktdata))), label='volatility')
tail(applyIndicators(strategy.name, ETHBTC))
head(ETHBTC)
head(emaVolatility(ETHBTC))
head(emaVolatility(Cl(ETHBTC)))
applyStrategy()
applyStrategy
applyIndicators
head(Cl(mktdata))
MACD
source('~/GitHub/altfund/backtester.R')
applyStrategy
?applyRules
tail(applyRules(portfolio.name, ETHBTC, strategy.name))
tail(applyRules(portfolio.name, ETHBTC, strategy.name, mktdata=mktdata))
head(mktdata)
tail(applyRules(portfolio.name, "ETHBTC", strategy.name, mktdata=mktdata))
mktdata
mktdata <- applyIndicators(strategy.name, ETHBTC)
head(mktdata)
tail(applyRules(portfolio.name, "ETHBTC", strategy.name, mktdata=mktdata))
add.rule(strategy.name, 'subsystemPosition',
arguments=list(rebalance_on='hours',
trade.percent=.02,
refprice=quote(last(getPrice(mktdata)[paste('::',curIndex,sep='')])[,1]),
digits=0
),
type='rebalance',
label='rebalance')
tail(applyRules(portfolio.name, "ETHBTC", strategy.name, mktdata=mktdata))
head(mktdata)
subsystemPosition <- function (trade.percent=.02,
...,
longlevels=1,
shortlevels=1,
digits=NULL,
refprice=NULL,
portfolio,
symbol,
timestamp)
{
dummy <- updatePortf(Portfolio=portfolio,
Dates=paste('::',timestamp,sep=''))
trading.pl <- sum(.getPortfolio(portfolio)$summary$Net.Trading.PL)
total.equity <- initEq+trading.pl
tradeSize <- total.equity * trade.percent
if(length(refprice)>1) refprice <- refprice[,1]
if(!is.null(refprice)) tradeSize <- tradeSize/refprice
if(!is.null(digits)) tradeSize<-round(tradeSize,digits)
addPosLimit(portfolio = portfolio,
symbol = symbol,
timestamp = timestamp,
maxpos = tradeSize,
longlevels = longlevels,
minpos = -tradeSize,
shortlevels = shortlevels)
}
add.rule(strategy.name, 'subsystemPosition',
arguments=list(rebalance_on='hours',
trade.percent=.02,
refprice=quote(last(getPrice(mktdata)[paste('::',curIndex,sep='')])[,1]),
digits=0
),
type='rebalance',
label='rebalance')
## Run it
applyStrategy.rebalancing(strategy.name,
portfolios=portfolio.name, debug=T,
parameters=list(),
verbose=TRUE)
portfolio.name <- "bitcoin_margin"
account.name <- "poloniex"
strategy.name <- "asset_allocation"
symbols <- c("ETHBTC") #, "BTCUSD")
## To rerun
rm.strat(portfolio.name)
rm.strat(account.name)
rm.strat(strategy.name)
## Initialize Portfolio, Account, and Orderbook
initPortf(name = portfolio.name, symbols = symbols, initPosQty = 0, initDate = initDate, currency = "BTC")  # getPortfolio(portfolio.name)
initAcct(name = account.name, portfolios = portfolio.name, initDate = initDate, initEq = 0, currency = "USD")  # getAccount(account.name)
initOrders(portfolio = portfolio.name, symbols = symbols, initDate = initDate)  # getOrderBook(portfolio.name)
strategy(strategy.name, store = TRUE)  # summary(getStrategy(strategy.name))
add.indicator(strategy.name, name= "emaVolatility", arguments = list(price.xts=quote(Cl(mktdata))), label='volatility')
add.indicator(strategy.name, name="scaledForecast", arguments = list(price.xts=quote(Cl(mktdata))), label='forecast')
add.rule(strategy.name, 'subsystemPosition',
arguments=list(rebalance_on='hours',
trade.percent=.02,
refprice=quote(last(getPrice(mktdata)[paste('::',curIndex,sep='')])[,1]),
digits=0
),
type='rebalance',
label='rebalance')
applyStrategy.rebalancing(strategy.name,
portfolios=portfolio.name, debug=T,
parameters=list(),
verbose=TRUE)
?initAcct
source('~/GitHub/altfund/backtester.R')
source('~/GitHub/altfund/backtester.R')
dummy <- updatePortf(Portfolio=portfolio,
Dates=paste('::',"2015-08-08 05:55:00 UTC",sep=''))
dummy <- updatePortf(Portfolio=portfolio.name,
Dates=paste('::',"2015-08-08 05:55:00 UTC",sep=''))
summary(dummy)
dummy
.getPortfolio(dummy)
.getPortfolio(dummy)$summary
.getPortfolio(dummy)$summary$Net.Trading.PL
.getPortfolio(dummy)$summary
.getPortfolio(dummy)$currency
source('~/GitHub/altfund/backtester.R')
?initPortf
initPortf
